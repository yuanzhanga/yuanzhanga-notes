在VUE中使用REACT组件

src/views/wms-basic/storage-area-setting/outbound-staging-location/hybrid.ts文件

import reactContainerFactory from '@/components/react-container/reactContainerFactory';
import { FC, lazy, LazyExoticComponent } from 'react';

export const CheckingStagingCompFactory = reactContainerFactory({//用于将 React 组件包装成可以在 Vue 中使用的组件
  name: 'outboundstaging.checking',
});

export const checkingStagingComp = (): LazyExoticComponent<FC> =>//懒加载函数
  lazy(
    () =>
      import(
        '@/react-app/pages/wms-basic/storage-area-setting/outbound-staging-location/checking-staging'
      )
  );




性能优化计算
计算fps
let lastTime = performance.now();
let frames = 0;
const loop = () => {
    const currentTime = performance.now();
    frames += 1;
    if (currentTime >= 1000 + lastTime) {
        fps = Math.round((frames * 1000) / (currentTime - lastTime));
        frames = 0;
        lastTime = currentTime;
        console.log(`fps:${fps}`);
    }
    window.requestAnimationFrame(loop);
}
  
loop();


帧率掉帧检测 + 分段采样上报
tick(fps: number) {
    const prevFps = getLastItem(this.dropPrevPoints);
    const standardFps = prevFps * (1 - this.dropRate);
    if (fps < standardFps) { // 如果帧率下跌超过 10%
      if (this.fpsList.length) {
        const lastDropFps = getLastItem(this.fpsList);
        if (fps < lastDropFps * (1 - this.dropRate)) {
          this.prevFpsPoints.push(lastDropFps);
          // 调用上报回调函数
          this.callback(this.fpsList.slice());
          this.fpsList = [fps];
        } else {
          this.fpsList.push(fps);
        }
      } else {
        this.fpsList.push(fps);
      }
    } else {
      if (this.fpsList.length) {
        // 调用上报回调函数
        this.callback(this.fpsList.slice());
        this.fpsList = [];
      }
      let index = -1;
      for (let i = this.dropPrevPoints.length - 1; i >= 0; i--) {
        const currentFps = this.dropPrevPoints[i] * (1 - this.dropRate);
        if (fps < currentFps) {
          index = i;
          break;
        }
      }
      if (index === -1) {
        this.prevFpsPoints = [this.dropPrevPoints[0]];
      } else {
        this.prevFpsPoints = this.dropPrevPoints.splice(0, index + 1);
        this.fpsList.push(fps);
      }
    }
  }

  function showNavigationDetails() {
    const [entry] = performance.getEntriesByType("navigation");
    console.table(entry.toJSON());//观察计算性能指标
  }

  padStart(n, t)向左用t补全字符，直到达到指定长度n
  


权限脚本cicd
1.双向匹配策略
从 PermissionKey 向下找 URL
从 API 调用向上找 PermissionKey
确保两种写法都能被识别
2.行号精确定位
利用 Git diff 的行号信息
通过行号直接定位到源码对应行
避免全文扫描，提升效率
3.多分隔符支持
支持 &、|、,、# 等分隔符
自动去重，避免重复上传

确定用户和分支名
  ↓
Git Diff
  ↓
line-number.sh 解析
  ↓
diff 文件（内容改变的行号:代码内容）
  ↓
_getPermissonRes() diff文件逐行解析，正则匹配文件名、文件里的权限点、API URL
  ↓
文件结构数组（文件名、权限点、API URL）
[
  {
    fileName: 'src/api/task-center/reassessment-task.ts',
    permissions: [
      { permissionKey: 'PC.Inbound.Task.ReassessmentTask.View', line: '59' }
    ],
    apis: [
      { url: '/api/v2/apps/process/inbound/poqc/create_communication', line: '60' }
    ]
  }
]
  ↓
_handleNotePermission() 匹配
  ↓
将源文件根据行依次添加到数组进行匹配工作
权限-URL 配对列表 双向匹配：根据对应line值确定数组行位置 从 PermissionKey 向下找 URL，从 API 向上找 PermissionKey
  ↓
_formatSuccessList() 格式化权限列表 处理&｜，#特殊字符
  ↓
最终权限列表 [{be_key, url}, ...]
  ↓
batchUploadPermission() 上传
  ↓
使用用户邮箱生成JWT 根据分支名确定jira单号
发送HTTP请求 服务器绑定权限
  ↓
deleleDiffFile() 清理diff文件



vue集成react
      vue-router
    vue         容器处理
vue2,vuex3   react17,zustand
Vuex Store与React组件间的通讯基于 React.useSyncExternalStore 封装

状态管理方案： 核心诉求是：可跨react应用共享。由于React应用被挂载在Vue路由下，每次切换页面都会经历卸载和重新渲染react应用的过程，所以可跨react应用的状态共享方案是必须的
选用 zustand 方案，其主要特性如下：
  全局状态持久化存储，可跨react应用共享
  框架无关，状态可在react组件外、vue中被使用
  写法简洁，贴合hooks
  有middleware机制，社区第三方实现丰富
  支持同步和异步action
  Typescript友好
  原子化状态设计，可实现Code Splitting