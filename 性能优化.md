流畅性	FPS	网页的每秒渲染次数，通常用于衡量页面动画的流程性	
加载性能
LCP ( Largest Contentful Paint ):用于记录视窗内最大内容绘制的时间，该时间会随着页面渲染变化而变化，因为页面中的最大元素在渲染过程中可能会发生改变，另外该指标会在用户第一次交互后停止记录	
TTI ( Time To Interactive )可交互时间:TTI 指标测量页面从开始加载到主要子资源完成渲染，并能够快速、可靠地响应用户输入所需的时间	时间点：至少5秒的安静窗口前的最后一个长任务的结束时间，（安静窗口：没有长任务且不超过两个正在处理的网络 GET 请求）。
TBT (Total Blocking Time)总阻塞时间:FCP 与 TTI 之间的阻塞时间总和,计算公式：TTI - FCP

性能优化计算
计算fps
let lastTime = performance.now();
let frames = 0;
const loop = () => {
    const currentTime = performance.now();
    frames += 1;
    if (currentTime >= 1000 + lastTime) {
        fps = Math.round((frames * 1000) / (currentTime - lastTime));
        frames = 0;
        lastTime = currentTime;
        console.log(`fps:${fps}`);
    }
    window.requestAnimationFrame(loop);
}
  
loop();


帧率掉帧检测 + 分段采样上报
dropPrevPoints：Array<number> 掉帧前的 FPS，比如上图中红色箭头所指的 58 和 45
dropRate: number 掉帧比率，默认 10% 值为 0.1
fpsList: Array<number> 收集起来的同一个范围内的 fps 集合，当下一帧率超出波动范围时，就上报这一集合的平均值
tick(fps: number) {
    const prevFps = getLastItem(this.dropPrevPoints);
    const standardFps = prevFps * (1 - this.dropRate);
    if (fps < standardFps) { // 如果帧率下跌超过 10%
      if (this.fpsList.length) {
        const lastDropFps = getLastItem(this.fpsList);
        if (fps < lastDropFps * (1 - this.dropRate)) {
          this.prevFpsPoints.push(lastDropFps);
          // 调用上报回调函数
          this.callback(this.fpsList.slice());
          this.fpsList = [fps];
        } else {
          this.fpsList.push(fps);
        }
      } else {
        this.fpsList.push(fps);
      }
    } else {
      if (this.fpsList.length) {
        // 调用上报回调函数
        this.callback(this.fpsList.slice());
        this.fpsList = [];
      }
      let index = -1;
      for (let i = this.dropPrevPoints.length - 1; i >= 0; i--) {
        const currentFps = this.dropPrevPoints[i] * (1 - this.dropRate);
        if (fps < currentFps) {
          index = i;
          break;
        }
      }
      if (index === -1) {
        this.prevFpsPoints = [this.dropPrevPoints[0]];
      } else {
        this.prevFpsPoints = this.dropPrevPoints.splice(0, index + 1);
        this.fpsList.push(fps);
      }
    }
  }

LCP计算：
new PerformanceObserver((entryList) => {
  for (const entry of entryList.getEntries()) {
    console.log('LCP candidate:', entry.startTime, entry);
  }
}).observe({type: 'largest-contentful-paint', buffered: true});

TTI polyfill 的计算思路：
重写 XMLHttpRequest 和 fetch 方法，维护一个"未完成的请求" 的数据，在请求时收集，请求结束后移除。
使用 PerformanceObserver 观测 resource 、longTask 两种类型的性能数据（有开始时间和结束时间）
 PerformanceObserver 能监听每次 resource资源加载和 longTask 长任务，每当资源加载结束和长任务结束后，都会在 5s 后去计算是否满足 TTI 的条件
如果当前时间已经超过 5 秒没有长任务和不超过两个正在处理的网络 GET 请求，就返回最后一个长任务的结束时间
  function showNavigationDetails() {
    const [entry] = performance.getEntriesByType("navigation");
    console.table(entry.toJSON());//观察计算性能指标
  }


白屏时间（FP）：页面开始展示的时间点 - 开始请求的时间点
影响白屏时间的因素：网络、服务端性能、前端页面结构设计
可以在html文档的head中所有的静态资源以及内嵌脚本/样式之前记录一个时间点，在head最底部记录另一个时间点，（两个script标签计算时间）两者的差值作为白屏时间
优化：SSR
    预渲染
    骨架屏

首屏时间（FCP）：首屏内容渲染结束时间点 - 开始请求的时间点
计算方法：标记首屏标签模块,统计首屏最慢图片加载时间,根据首屏内接口计算比较得出最迟的时间
  首屏时间：performance.getEntriesByName("first-contentful-paint")[0].startTime - performance.getEntriesByType('navigation')[0].startTime
优化首屏加载时间的方法：
    CDN分发（减少传输距离）
    后端在业务层的缓存
    静态文件缓存方案
    前端的资源动态加载
    减少请求的数量
    利用好HTTP压缩

performance
属性：memory：显示此刻内存占用情况
          usedJSHeapSize：JS对象占用的内存数
          jsHeapSizeLimit：可使用的内存
          totalJSHeapSize：内存大小限制
      正常usedJSHeapSize不大于totalJSHeapSize，如果大于，说明可能出现了内存泄漏。
    navigation：显示页面的来源信息
    timing：一系列关键时间点，包含网络、解析等一系列的时间数据
          重定向耗时：redirectEnd - redirectStart
          DNS查询耗时：domainLookupEnd - domainLookupStart
          TCP链接耗时：connectEnd - connectStart
          HTTP请求耗时：responseEnd - responseStart
          解析dom树耗时：domComplete - domInteractive
          白屏时间：responseStart - navigationStart
          DOM ready时间：domContentLoadedEventEnd - navigationStart
          onload时间：loadEventEnd - navigationStart
  